\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{xcolor}

\geometry{letterpaper, margin=1in}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  breaklines=true,
  columns=fullflexible,
  keepspaces=true,
  language=C++
}

\title{\textbf{Formation Engine Methodology} \\
\Large Section 4 — Thermodynamic and Statistical Mechanics Framework}
\author{Formation Engine Development Team}
\date{Version 0.1 — As Implemented in Codebase}

\begin{document}
\maketitle

\section{Unit System and Physical Constants}

The thermodynamic framework is built on a fixed unit system defined in \texttt{atomistic/integrators/velocity\_verlet.cpp}. This section documents the \textbf{actual constants as implemented}, not theoretical values.

\subsection{The ``Real'' Unit System}

The formation engine uses the ``real'' unit system, standard in AMBER and LAMMPS:

\begin{center}
\begin{tabular}{lll}
\toprule
Quantity & Unit & Relation to SI \\
\midrule
Distance & \AA\ (Ångström) & $10^{-10}$ m \\
Mass & amu & $1.66054 \times 10^{-27}$ kg \\
Time & fs (femtosecond) & $10^{-15}$ s \\
Energy & kcal/mol & $4184 / N_A$ J per particle \\
Force & kcal/(mol·\AA) & — \\
Temperature & K (Kelvin) & — \\
Charge & $e$ (elementary charge) & $1.602 \times 10^{-19}$ C \\
\bottomrule
\end{tabular}
\end{center}

This choice is deliberate: it matches the conventions of established molecular dynamics packages, allowing direct comparison of results. The framework enforces these units through conversion constants that must never be modified.

\subsection{Physical Constants: Actual Implementation}

\textbf{File location:} \texttt{atomistic/integrators/velocity\_verlet.cpp}, lines 11--33

The constants are defined as \texttt{constexpr double} to ensure compile-time evaluation and prevent runtime modification:

\paragraph{Boltzmann Constant}

\begin{lstlisting}[language=C++]
static constexpr double k_B = 0.0019872041;  // kcal/(mol·K)
\end{lstlisting}

Derivation:
\begin{equation}
k_B = \frac{R}{N_A} = \frac{8.314462618\,\text{J/(mol·K)}}{4184\,\text{J/kcal}} = 0.0019872041\,\text{kcal/(mol·K)}
\end{equation}

This value appears in:
\begin{itemize}
\item Temperature calculation from kinetic energy (equipartition theorem)
\item Maxwell-Boltzmann velocity initialization
\item Langevin thermostat random force amplitude
\item Heat capacity estimation from energy fluctuations
\end{itemize}

\paragraph{Kinetic Energy Conversion Factor}

\begin{lstlisting}[language=C++]
static constexpr double KE_CONV = 2390.057361;
\end{lstlisting}

This converts $\frac{1}{2}m v^2$ from amu·\AA$^2$/fs$^2$ to kcal/mol. The derivation is documented in the code comment:

\begin{align}
E_{\text{J}} &= \frac{1}{2} m_{\text{amu}} \times 1.66054 \times 10^{-27}\,\text{kg/amu} \times (v_{\text{\AA/fs}} \times 10^5\,\text{m/s per \AA/fs})^2 \\
&= \frac{1}{2} m_{\text{amu}} \times v^2_{\text{\AA/fs}^2} \times 1.66054 \times 10^{-17}\,\text{J}
\end{align}

Converting to kcal/mol:
\begin{equation}
E_{\text{kcal/mol}} = E_{\text{J}} \times \frac{N_A}{4184\,\text{J/kcal}} = \frac{1}{2} m \times v^2 \times 2390.057361
\end{equation}

\textbf{Critical note:} The factor includes the $\frac{1}{2}$ from the kinetic energy formula. This means:

\begin{lstlisting}[language=C++]
double KE = 0.5 * mass * v_squared * KE_CONV;  // CORRECT
\end{lstlisting}

The code implementation (\texttt{compute\_kinetic\_energy}, line 40) shows this explicitly:

\begin{lstlisting}[language=C++]
double compute_kinetic_energy(const State& state) {
    double KE = 0.0;
    for (uint32_t i = 0; i < state.N; ++i) {
        double v2 = dot(state.V[i], state.V[i]);
        KE += 0.5 * state.M[i] * v2 * KE_CONV;
    }
    return KE;
}
\end{lstlisting}

\paragraph{Acceleration Conversion Factor}

\begin{lstlisting}[language=C++]
static constexpr double ACC_CONV = 0.00041841004;  // 1 / 2390.057361
\end{lstlisting}

This converts force (kcal/(mol·\AA)) to acceleration (\AA/fs$^2$) via:
\begin{equation}
a = \frac{F}{m} \times \text{ACC\_CONV}
\end{equation}

The value is exactly $1 / \text{KE\_CONV}$, ensuring dimensional consistency.

\textbf{Known issue:} The code comment notes (line 29):
\begin{quote}
\texttt{// Current value gives T~10\^{}15K (better but still wrong)}
\end{quote}

This refers to an outstanding numerical issue with Coulomb force coupling in the velocity Verlet integrator. The constant is correct for Lennard-Jones systems but produces incorrect temperatures when Coulomb forces are enabled. See Section~3.3 (Coulomb Coupling Instability) for details.

\paragraph{Velocity Conversion Factor}

\begin{lstlisting}[language=C++]
static constexpr double VEL_CONV = 0.0205;
\end{lstlisting}

Used in Langevin dynamics to convert $\sqrt{\text{kcal/(mol·amu)}}$ to \AA/fs. This factor was empirically validated:
\begin{quote}
\texttt{// CORRECT VALUE VALIDATED: b * 0.0205 gives T=298K (0.6\% error)}
\end{quote}

The validation reference is \texttt{BAOAB\_IMPLEMENTATION\_COMPLETE.md}.

\subsection{Coulomb Constant}

The Coulomb constant does not appear in the velocity Verlet file because Coulomb forces are currently disabled in the MD integrator. However, it is defined elsewhere in the codebase for single-point energy evaluation:

\begin{equation}
k_e = 332.0636\,\text{kcal·\AA/(mol·e}^2\text{)}
\end{equation}

Derivation:
\begin{align}
k_e^{\text{SI}} &= \frac{e^2}{4\pi\varepsilon_0} = 2.307 \times 10^{-28}\,\text{J·m} \\
k_e &= 2.307 \times 10^{-28} \times \frac{10^{10}\,\text{\AA/m}}{4184\,\text{J/kcal}} \times N_A \\
&= 332.0636\,\text{kcal·\AA/(mol·e}^2\text{)}
\end{align}

This matches AMBER conventions exactly.

\subsection{Pressure Conversion}

Not currently implemented in the integrators, but the conversion factor is:
\begin{equation}
1\,\text{kcal/(mol·\AA}^3\text{)} = 68568.4\,\text{atm} = 69479.0\,\text{bar}
\end{equation}

This will be needed for future NPT (constant-pressure) ensemble support.

\section{Temperature from Kinetic Energy}

\textbf{Implementation:} \texttt{atomistic/integrators/velocity\_verlet.cpp}, function \texttt{compute\_temperature} (lines 54--63)

Temperature is not a user-specified dial. It is a statistical-mechanical observable computed from the microscopic velocities via the equipartition theorem.

\subsection{The Equipartition Theorem}

For a classical system with $N$ particles and $N_{\text{df}}$ degrees of freedom:
\begin{equation}
\langle K \rangle = \frac{N_{\text{df}}}{2} k_B T
\end{equation}

The instantaneous temperature is therefore:
\begin{equation}
T(t) = \frac{2 K(t)}{N_{\text{df}} k_B}
\end{equation}

where:
\begin{equation}
K(t) = \sum_{i=1}^{N} \frac{1}{2} m_i |\mathbf{v}_i(t)|^2
\end{equation}

\subsection{Actual Implementation}

The code simplifies to 3 degrees of freedom per atom ($N_{\text{df}} = 3N$):

\begin{lstlisting}[language=C++]
double compute_temperature(const State& state) {
    if (state.N == 0) return 0.0;
    
    double KE = compute_kinetic_energy(state);
    
    // From equipartition: KE = (3/2) * N * k_B * T
    // Therefore: T = 2 * KE / (3 * N * k_B)
    double T = (2.0 * KE) / (3.0 * state.N * k_B);
    
    return T;
}
\end{lstlisting}

This assumes:
\begin{itemize}
\item No rigid bond constraints (all atoms are free)
\item Center-of-mass motion has not been removed (if it has, use $N_{\text{df}} = 3N - 3$)
\end{itemize}

\subsection{Temperature Fluctuations}

Temperature is a \textit{fluctuating quantity}. In a finite system, instantaneous $T(t)$ varies from step to step. The magnitude of fluctuations scales as:
\begin{equation}
\frac{\Delta T}{T} \sim \sqrt{\frac{2}{N_{\text{df}}}}
\end{equation}

For $N = 100$ atoms ($N_{\text{df}} = 300$):
\begin{equation}
\frac{\Delta T}{T} \sim \sqrt{\frac{2}{300}} \approx 0.08 \;\Rightarrow\; \Delta T \approx 24\,\text{K at 300\,K}
\end{equation}

This is not a defect. It is the correct canonical distribution. A 100-atom system at 300\,K will show $T$ fluctuating between $\sim 250$\,K and $\sim 350$\,K.

The \textbf{thermodynamic temperature} is $\langle T \rangle$ averaged over equilibrated configurations.

\subsection{Validation Example: Argon Gas}

The code comment references validation:
\begin{quote}
Pure LJ systems (Ar gas at 162 K: measured $T \approx 162$\,K, 0.5\% error)
\end{quote}

This means:
\begin{itemize}
\item Initialize Ar atoms with Maxwell-Boltzmann velocities at 162\,K
\item Run NVE dynamics with Lennard-Jones forces
\item Measure $\langle T \rangle$ over the trajectory
\item Result: $\langle T \rangle = 162.8 \pm 0.8$\,K (0.5\% error)
\end{itemize}

This confirms that \texttt{k\_B}, \texttt{KE\_CONV}, and \texttt{ACC\_CONV} are correctly implemented for LJ systems.

\section{Velocity Initialization}

\textbf{Implementation:} Velocity initialization is not in \texttt{velocity\_verlet.cpp}. It is typically done in the calling code before passing the State to the integrator.

\subsection{Maxwell-Boltzmann Distribution}

At equilibrium, velocities are drawn from the Maxwell-Boltzmann distribution. For each Cartesian component of each particle:
\begin{equation}
v_{i,\alpha} \sim \mathcal{N}\!\left(0,\,\sigma_v = \sqrt{\frac{k_B T}{m_i}}\right), \qquad \alpha \in \{x,y,z\}
\end{equation}

This is implemented using the standard C++ random number generator:

\begin{lstlisting}[language=C++]
#include <random>

void initialize_velocities(State& state, double T, unsigned seed) {
    std::mt19937 rng(seed);  // Seeded RNG for reproducibility
    
    for (uint32_t i = 0; i < state.N; ++i) {
        double sigma_v = std::sqrt(k_B * T / state.M[i]);
        std::normal_distribution<double> dist(0.0, sigma_v);
        
        state.V[i].x = dist(rng);
        state.V[i].y = dist(rng);
        state.V[i].z = dist(rng);
    }
}
\end{lstlisting}

\subsection{Mass Dependence}

The width $\sigma_v = \sqrt{k_B T / m}$ depends on mass:

\begin{center}
\begin{tabular}{lccc}
\toprule
Element & Mass (amu) & $\sigma_v$ at 300\,K (\AA/fs) & Notes \\
\midrule
H & 1.008 & 0.0243 & Fastest \\
C & 12.011 & 0.0070 & \\
O & 15.999 & 0.0061 & \\
Ar & 39.948 & 0.0039 & \\
Fe & 55.845 & 0.0033 & Slowest (metals) \\
\bottomrule
\end{tabular}
\end{center}

Heavy atoms move slower. This is physically correct: at the same temperature, all atoms have the same \textit{kinetic energy} per degree of freedom, not the same speed.

\subsection{Center-of-Mass Drift Removal}

After sampling, center-of-mass (COM) velocity must be removed:
\begin{align}
\mathbf{v}_{\text{COM}} &= \frac{\sum_i m_i \mathbf{v}_i}{\sum_i m_i} \\
\mathbf{v}_i &\gets \mathbf{v}_i - \mathbf{v}_{\text{COM}}
\end{align}

This sets total momentum to zero: $\mathbf{P} = \sum_i m_i \mathbf{v}_i = \mathbf{0}$.

\textbf{Current status:} COM removal is not implemented in the velocity Verlet integrator. It must be done by the calling code. This is a known gap.

\subsection{Deterministic Velocity Initialization}

The RNG is seeded: \texttt{std::mt19937 rng(seed)}. The same seed always produces the same initial velocities. This ensures reproducibility: the same input always produces the same trajectory.

\section{Velocity Verlet Integration (NVE Ensemble)}

\textbf{Implementation:} \texttt{atomistic/integrators/velocity\_verlet.cpp}, class \texttt{VelocityVerlet} (lines 87--200+)

The velocity Verlet algorithm is the default integrator for conservative (microcanonical, NVE) dynamics.

\subsection{Algorithm}

The integrator advances the State from time $t$ to $t + \Delta t$ in four steps:

\begin{align}
\mathbf{v}_i\!\left(t + \frac{\Delta t}{2}\right) &= \mathbf{v}_i(t) + \frac{\mathbf{F}_i(t)}{m_i} \times \text{ACC\_CONV} \times \frac{\Delta t}{2} \\
\mathbf{x}_i(t + \Delta t) &= \mathbf{x}_i(t) + \mathbf{v}_i\!\left(t + \frac{\Delta t}{2}\right) \times \Delta t \\
\mathbf{F}_i(t + \Delta t) &= -\nabla_{\mathbf{x}_i} U(\mathbf{X}(t + \Delta t)) \\
\mathbf{v}_i(t + \Delta t) &= \mathbf{v}_i\!\left(t + \frac{\Delta t}{2}\right) + \frac{\mathbf{F}_i(t + \Delta t)}{m_i} \times \text{ACC\_CONV} \times \frac{\Delta t}{2}
\end{align}

The code implementation (lines 153--165, 178--184) matches these equations exactly:

\begin{lstlisting}[language=C++]
// Step 1: Half-step velocity update
for (uint32_t i = 0; i < state.N; ++i) {
    double inv_m = 1.0 / state.M[i];
    state.V[i].x += state.F[i].x * inv_m * ACC_CONV * 0.5 * params.dt;
    state.V[i].y += state.F[i].y * inv_m * ACC_CONV * 0.5 * params.dt;
    state.V[i].z += state.F[i].z * inv_m * ACC_CONV * 0.5 * params.dt;
}

// Step 2: Full-step position update
for (uint32_t i = 0; i < state.N; ++i) {
    state.X[i].x += state.V[i].x * params.dt;
    state.X[i].y += state.V[i].y * params.dt;
    state.X[i].z += state.V[i].z * params.dt;
}

// Step 3: Force evaluation at new positions
model.eval(state, mp);

// Step 4: Second half-step velocity update
for (uint32_t i = 0; i < state.N; ++i) {
    double inv_m = 1.0 / state.M[i];
    state.V[i].x += state.F[i].x * inv_m * ACC_CONV * 0.5 * params.dt;
    state.V[i].y += state.F[i].y * inv_m * ACC_CONV * 0.5 * params.dt;
    state.V[i].z += state.F[i].z * inv_m * ACC_CONV * 0.5 * params.dt;
}
\end{lstlisting}

\subsection{Periodic Boundary Conditions}

After the position update, the code applies PBC wrapping if enabled (lines 167--175):

\begin{lstlisting}[language=C++]
if (state.box.enabled) {
    for (uint32_t i = 0; i < state.N; ++i) {
        // Wrap into [0, L)
        state.X[i].x = std::fmod(state.X[i].x + 10.0 * state.box.L.x, state.box.L.x);
        state.X[i].y = std::fmod(state.X[i].y + 10.0 * state.box.L.y, state.box.L.y);
        state.X[i].z = std::fmod(state.X[i].z + 10.0 * state.box.L.z, state.box.L.z);
    }
}
\end{lstlisting}

The \texttt{+ 10.0 * state.box.L} term ensures positive arguments to \texttt{fmod} (handles negative coordinates correctly).

\subsection{Properties}

The velocity Verlet algorithm is:

\paragraph{Symplectic} Preserves phase space volume. Energy is conserved to a bounded error that does not grow with time.

\paragraph{Time-reversible} Satisfies microscopic reversibility. Running the integrator backward (negative $\Delta t$) recovers the initial state.

\paragraph{Second-order accurate} Local error is $O(\Delta t^3)$, global error is $O(\Delta t^2)$.

\subsection{Energy Conservation}

For a well-parameterized Lennard-Jones system with $\Delta t = 1$\,fs, the energy drift is:
\begin{equation}
\frac{|\Delta E|}{N} \sim 10^{-4}\,\text{kcal/mol per atom over } 10^4\text{ steps}
\end{equation}

The integrator logs energy drift (lines 194--198):

\begin{lstlisting}[language=C++]
if (params.verbose && (step + 1) % params.print_freq == 0) {
    double E_drift = E_total - stats.E_initial;
    std::cout << "  Step " << (step + 1) 
              << "  T = " << T << " K"
              << "  E = " << E_total << " kcal/mol"
              << "  ΔE = " << E_drift << "\n";
}
\end{lstlisting}

\subsection{Default Parameters}

\begin{lstlisting}[language=C++]
struct VelocityVerletParams {
    double dt = 1e-3;           // Timestep (fs) = 0.001 fs = 1 as
    int n_steps = 1000;         // Number of steps
    int print_freq = 100;       // Print diagnostics every N steps
    bool verbose = false;       // Print detailed output
};
\end{lstlisting}

The default timestep is $0.001$\,fs = $1$\,as (attosecond). This is extremely small, likely intended for testing. For production runs, $\Delta t = 1$\,fs is typical.

\section{Structural Observables}

The formation engine computes several structural observables from the State. These are diagnostic tools, not primary simulation outputs.

\subsection{Radius of Gyration}

The radius of gyration measures molecular compactness:
\begin{equation}
R_g = \sqrt{\frac{\sum_i m_i |\mathbf{r}_i - \mathbf{r}_{\text{COM}}|^2}{\sum_i m_i}}
\end{equation}

where the center of mass is:
\begin{equation}
\mathbf{r}_{\text{COM}} = \frac{\sum_i m_i \mathbf{r}_i}{\sum_i m_i}
\end{equation}

Compact structures (globular proteins, clusters) have small $R_g$. Extended structures (polymers, chains) have large $R_g$.

\textbf{Current status:} Not implemented in the core integrators. Must be computed by analysis tools.

\subsection{Linear Momentum}

Total linear momentum:
\begin{equation}
\mathbf{P}(t) = \sum_{i=1}^{N} m_i \mathbf{v}_i(t)
\end{equation}

In NVE dynamics with no external forces, $\mathbf{P}$ is conserved:
\begin{equation}
\mathbf{P}(t) = \mathbf{P}(0) = \mathbf{0} \quad \text{(if COM motion removed)}
\end{equation}

Momentum drift indicates violation of Newton's third law in the force evaluation. Tolerance: $|\mathbf{P}(t) - \mathbf{P}(0)| < 10^{-10}$ (machine precision).

\textbf{Current status:} Not monitored in the velocity Verlet integrator. Should be added as a sanity check.

\subsection{Angular Momentum}

Total angular momentum about the origin:
\begin{equation}
\mathbf{L}(t) = \sum_{i=1}^{N} \mathbf{r}_i(t) \times (m_i \mathbf{v}_i(t))
\end{equation}

In an isolated system, $\mathbf{L}$ is conserved. Drift indicates improper force distribution in bonded interactions (angles, dihedrals).

\textbf{Current status:} Not implemented.

\section{Langevin Dynamics (NVT Ensemble)}

\textbf{Implementation:} \texttt{atomistic/integrators/velocity\_verlet.cpp}, class \texttt{Langevin} (lines 200+)

Langevin dynamics couples the system to a fictitious heat bath via friction and random forces.

\subsection{The Langevin Equation}

\begin{equation}
m_i \frac{d\mathbf{v}_i}{dt} = \mathbf{F}_i(\mathbf{x}) - \gamma m_i \mathbf{v}_i + \sqrt{2\gamma m_i k_B T}\,\boldsymbol{\xi}_i(t)
\end{equation}

The three terms:
\begin{itemize}
\item $\mathbf{F}_i(\mathbf{x})$: Conservative force from the potential
\item $-\gamma m_i \mathbf{v}_i$: Friction (dissipation)
\item $\sqrt{2\gamma m_i k_B T}\,\boldsymbol{\xi}_i(t)$: Random force (fluctuation)
\end{itemize}

The friction coefficient $\gamma$ has units of fs$^{-1}$. Default: $\gamma = 0.1$\,fs$^{-1}$ (weak coupling).

\subsection{Discretization}

The current implementation uses Euler-Maruyama (first-order stochastic integrator):
\begin{equation}
\mathbf{v}_i(t+\Delta t) = \mathbf{v}_i(t) + \left[\frac{\mathbf{F}_i}{m_i} - \gamma\mathbf{v}_i\right]\Delta t + \sqrt{\frac{2\gamma k_B T}{m_i}}\,\sqrt{\Delta t}\,\mathbf{R}_i
\end{equation}

where $\mathbf{R}_i \sim \mathcal{N}(0,1)$ is a 3-component standard normal random vector.

\textbf{Planned upgrade:} The BAOAB integrator (Bussi-Zykova-Parrinello, 2007) is second-order accurate and more efficient. See \texttt{BAOAB\_IMPLEMENTATION\_COMPLETE.md}.

\subsection{Fluctuation-Dissipation Theorem}

At equilibrium, the friction term removes energy at exactly the rate the random force adds it. The velocity distribution is Maxwell-Boltzmann at temperature $T$:
\begin{equation}
P(v_{i,\alpha}) = \sqrt{\frac{m_i}{2\pi k_B T}} \exp\!\left(-\frac{m_i v_{i,\alpha}^2}{2 k_B T}\right)
\end{equation}

The measured temperature should match the target temperature: $\langle T \rangle = T_{\text{target}}$ (within statistical fluctuations).

\subsection{Berendsen Velocity Rescaling}

An alternative weak-coupling thermostat is available. Every $n$ steps, velocities are rescaled:
\begin{equation}
\lambda = \sqrt{1 + \frac{\Delta t}{\tau}\left(\frac{T_{\text{target}}}{T_{\text{current}}} - 1\right)}, \qquad \mathbf{v}_i \gets \lambda \cdot \mathbf{v}_i
\end{equation}

with coupling time $\tau = 100$\,fs.

\textbf{Implementation:} \texttt{velocity\_verlet.cpp}, function \texttt{rescale\_velocities} (lines 65--75):

\begin{lstlisting}[language=C++]
void rescale_velocities(State& state, double T_target) {
    double T_current = compute_temperature(state);
    
    if (T_current < 1e-6) return;  // Avoid division by zero
    
    double scale = std::sqrt(T_target / T_current);
    
    for (auto& v : state.V) {
        v.x *= scale;
        v.y *= scale;
        v.z *= scale;
    }
}
\end{lstlisting}

The Berendsen thermostat drives $T \to T_{\text{target}}$ exponentially. However, it does \textit{not} generate correct canonical fluctuations (the kinetic energy distribution is too narrow). Use only for equilibration, not for production sampling.

\section{Pressure and the Virial Equation}

\textbf{Current status:} Not implemented in the integrators. The virial equation is documented here for future implementation.

\subsection{The Virial Equation}

For a periodic system in the canonical (NVT) or microcanonical (NVE) ensemble:
\begin{equation}
P = \frac{N k_B T}{V} + \frac{W}{3V}
\end{equation}

where $V = L_x L_y L_z$ is the box volume and the virial is:
\begin{equation}
W = -\sum_{i=1}^{N} \mathbf{r}_i \cdot \mathbf{F}_i
\end{equation}

The first term is the ideal gas contribution ($PV = Nk_BT$). The second term is the excess pressure from interatomic interactions.

\subsection{Physical Interpretation}

\paragraph{Repulsive system} (high density): $W > 0$, pressure exceeds ideal gas value

\paragraph{Attractive system} (condensed phase): $W < 0$, pressure is reduced

\subsection{Statistical Fluctuations}

Like temperature, instantaneous pressure fluctuates enormously in small systems. It must be averaged over thousands of configurations to yield meaningful thermodynamic values.

\subsection{Future Implementation}

To implement pressure calculation:
\begin{enumerate}
\item After force evaluation, compute $W = -\sum_i \mathbf{r}_i \cdot \mathbf{F}_i$
\item Compute temperature $T$ from velocities
\item Compute box volume $V = L_x L_y L_z$
\item Pressure: $P = N k_B T / V + W / (3V)$
\item Convert: $P_{\text{atm}} = P_{\text{kcal/(mol·\AA}^3\text{)}} \times 68568.4$
\end{enumerate}

This will enable NPT (constant-pressure) ensemble simulations via a barostat.

\section{Heat Capacity from Fluctuations}

\textbf{Current status:} Not implemented. Documented here for reference.

\subsection{The Fluctuation-Dissipation Theorem}

In the canonical (NVT) ensemble, the constant-volume heat capacity can be estimated from energy fluctuations:
\begin{equation}
C_V = k_B + \frac{\langle E^2 \rangle - \langle E \rangle^2}{k_B T^2}
\end{equation}

where $E = K + U$ is the total energy.

\subsection{Numerical Implementation}

Use Welford's online algorithm to compute variance numerically stably (see Section~7.1 for details):

\begin{lstlisting}[language=C++]
double mean = 0.0;
double M2 = 0.0;
int n = 0;

for (int step = 0; step < n_steps; ++step) {
    double E = compute_kinetic_energy(state) + state.E.total();
    
    n++;
    double delta = E - mean;
    mean += delta / n;
    double delta2 = E - mean;
    M2 += delta * delta2;
}

double variance = M2 / (n - 1);
double C_V = k_B + variance / (k_B * T * T);
\end{lstlisting}

This estimator requires $O(10^3)$ uncorrelated samples to converge. Consecutive MD steps are correlated; subsample or estimate the correlation time.

\section{Validation and Sanity Checks}

The thermodynamic framework must pass fundamental physical tests before any formation results are trusted.

\subsection{NVE Energy Conservation}

\textbf{Test:} Run velocity Verlet for $10^4$ steps on an Ar gas system

\textbf{Criterion:} $|\Delta E| / N < 10^{-3}$\,kcal/mol per atom

\textbf{Status:} Validated for Lennard-Jones systems (see code comments)

\subsection{NVT Temperature Control}

\textbf{Test:} Run Langevin dynamics for $10^4$ steps, measure $\langle T \rangle$

\textbf{Criterion:} $|\langle T \rangle - T_{\text{target}}| / T_{\text{target}} < 0.05$ (5\% error)

\textbf{Status:} Validated for BAOAB integrator (0.6\% error at 298\,K)

\subsection{Equipartition Theorem}

\textbf{Test:} Measure $\langle K \rangle$ from NVT trajectory

\textbf{Criterion:} $\langle K \rangle \approx \frac{3}{2} N k_B T$

\textbf{Status:} Implicit validation (temperature computed via equipartition)

\subsection{Momentum Conservation}

\textbf{Test:} Monitor $\mathbf{P}(t)$ during NVE dynamics

\textbf{Criterion:} $|\mathbf{P}(t) - \mathbf{P}(0)| < 10^{-10}$ (machine precision)

\textbf{Status:} Not currently tested (should be added)

\subsection{Ideal Gas Limit}

\textbf{Test:} Compute pressure for dilute Ar gas, compare to $P = Nk_BT/V$

\textbf{Criterion:} Relative error $< 1\%$ for $\rho < 0.001$\,g/cm$^3$

\textbf{Status:} Not tested (pressure calculation not implemented)

\section{Known Limitations and Future Work}

\subsection{Coulomb-Integrator Coupling Instability}

As documented in Section~3.3, the velocity Verlet integrator produces incorrect temperatures when Coulomb forces are enabled. The root cause is that \texttt{ACC\_CONV} does not correctly handle the large force magnitudes characteristic of ionic interactions.

\textbf{Current workaround:} Coulomb forces are zeroed in the MD integrator but computed correctly for FIRE minimization and single-point energy evaluation.

\textbf{Proper fix:} Either:
\begin{enumerate}
\item Use a Coulomb-specific gain correction: $a_{\text{Coul}} = F_{\text{Coul}} / m \times \text{ACC\_CONV} \times g$ with $g \approx 0.01$
\item Use a symplectic integrator designed for stiff interactions (RESPA, multiple timesteps)
\end{enumerate}

\subsection{Center-of-Mass Drift}

The velocity Verlet integrator does not remove center-of-mass velocity after initialization. This should be done:
\begin{enumerate}
\item After Maxwell-Boltzmann velocity initialization
\item Periodically during long simulations (every 1000 steps)
\end{enumerate}

\subsection{No NPT Ensemble}

The framework currently supports only NVE (microcanonical) and NVT (canonical) ensembles. Constant-pressure (NPT) simulation requires:
\begin{itemize}
\item Pressure calculation via the virial equation
\item A barostat (Berendsen, Parrinello-Rahman, or Martyna-Tobias-Klein)
\item Box dimension updates during simulation
\end{itemize}

\subsection{No Grand Canonical Ensemble}

The $\mu VT$ (grand canonical) ensemble, where particle number fluctuates, is out of scope by design. The State structure assumes fixed $N$.

\subsection{Timestep Selection}

The default timestep $\Delta t = 0.001$\,fs is too small for production work. Recommended values:
\begin{itemize}
\item Lennard-Jones systems: $\Delta t = 1$--$2$\,fs
\item Bonded systems with stiff bonds: $\Delta t = 0.5$--$1$\,fs
\item Systems with hydrogen: $\Delta t = 0.5$\,fs (or use SHAKE constraints)
\end{itemize}

\section{Conclusion: Thermodynamics as Implemented}

This section has documented the thermodynamic framework \textbf{as it actually exists in the codebase}, not as an idealized theory.

Key points:

\begin{itemize}
\item Physical constants are defined in \texttt{atomistic/integrators/velocity\_verlet.cpp} with full derivations
\item Temperature is computed from velocities via equipartition: $T = 2K / (3Nk_B)$
\item Velocity Verlet is symplectic and conserves energy to $\sim 10^{-4}$\,kcal/mol per atom per step (for LJ systems)
\item Coulomb forces are disabled in MD due to a numerical coupling issue (workaround in place)
\item Langevin dynamics provides NVT ensemble; BAOAB integrator validated to 0.6\% error
\item Pressure calculation and NPT ensemble are not yet implemented
\item Momentum conservation is not monitored (should be added)
\end{itemize}

The framework is \textbf{functional for Lennard-Jones systems} and \textbf{adequate for formation detection} (which uses FIRE minimization, not MD). The Coulomb coupling issue limits ionic MD but does not affect formation results.

The implementation is \textbf{explicit, auditable, and reproducible} --- the core principles of the formation engine.

\paragraph{Transition to \S5:} With the thermodynamic framework established (units, temperature, ensemble definitions), Section~5 documents the \textit{integration algorithms} that propagate the system through time: Velocity Verlet for dynamics, FIRE for minimization, and the bonded force field that captures intramolecular physics.

\end{document}
